From 0000000000000000000000000000000000000000 Mon Sep 17 00:00:00 2001
From: Byron Marohn <combustible@live.com>
Date: Sat, 24 Oct 2020 14:57:50 -0400
Subject: [PATCH] Monumenta - Ensure minecraft:reload uses latest
 CommandDispatcher


diff --git a/src/main/java/net/minecraft/server/CustomFunctionManager.java b/src/main/java/net/minecraft/server/CustomFunctionManager.java
index 8f269c76c07a83299ac1e593e9f5c873eae22192..3847ff460b62adc7c9f37a802b69c3e6b32b0735 100644
--- a/src/main/java/net/minecraft/server/CustomFunctionManager.java
+++ b/src/main/java/net/minecraft/server/CustomFunctionManager.java
@@ -27,6 +27,7 @@ public class CustomFunctionManager implements IReloadListener {
     private volatile Tags<CustomFunction> f = Tags.c();
     private final int g;
     private final com.mojang.brigadier.CommandDispatcher<CommandListenerWrapper> h;
+    private static boolean initialFunctionLoad = true; // MONUMENTA
 
     public Optional<CustomFunction> a(MinecraftKey minecraftkey) {
         return Optional.ofNullable(this.d.get(minecraftkey));
@@ -54,7 +55,14 @@ public class CustomFunctionManager implements IReloadListener {
         CompletableFuture<Map<MinecraftKey, Tag.a>> completablefuture = this.e.a(iresourcemanager, executor);
         CompletableFuture<Map<MinecraftKey, CompletableFuture<CustomFunction>>> completablefuture1 = CompletableFuture.supplyAsync(() -> {
             return iresourcemanager.a("functions", (s) -> {
-                return s.endsWith(".mcfunction");
+                // MONUMENTA START
+                // Don't load functions the first time the server starts up
+                if (initialFunctionLoad) {
+                    return false;
+                } else {
+                    return s.endsWith(".mcfunction");
+                }
+                // MONUMENTA END
             });
         }, executor).thenCompose((collection) -> {
             Map<MinecraftKey, CompletableFuture<CustomFunction>> map = Maps.newHashMap();
@@ -83,7 +91,7 @@ public class CustomFunctionManager implements IReloadListener {
 
         ireloadlistener_a.getClass();
         return completablefuture2.thenCompose(ireloadlistener_a::a).thenAcceptAsync((pair) -> {
-            Map<MinecraftKey, CompletableFuture<CustomFunction>> map = (Map) pair.getSecond();
+            Map<MinecraftKey, CompletableFuture<CustomFunction>> map = (Map) ((Pair)pair).getSecond();
             Builder<MinecraftKey, CustomFunction> builder = ImmutableMap.builder();
 
             map.forEach((minecraftkey, completablefuture3) -> {
@@ -98,7 +106,8 @@ public class CustomFunctionManager implements IReloadListener {
                 }).join();
             });
             this.d = builder.build();
-            this.f = this.e.a((Map) pair.getFirst());
+            this.f = this.e.a((Map) ((Pair)pair).getFirst());
+            initialFunctionLoad = false;
         }, executor1);
     }
 
diff --git a/src/main/java/net/minecraft/server/DataPackResources.java b/src/main/java/net/minecraft/server/DataPackResources.java
index f6714515cc6b0265b772e5850301f6165c8f3d54..e83857b469fd6da50464f00caa46de3d3d0dcf28 100644
--- a/src/main/java/net/minecraft/server/DataPackResources.java
+++ b/src/main/java/net/minecraft/server/DataPackResources.java
@@ -7,6 +7,7 @@ import java.util.concurrent.Executor;
 public class DataPackResources implements AutoCloseable {
 
     private static final CompletableFuture<Unit> a = CompletableFuture.completedFuture(Unit.INSTANCE);
+    public static CommandDispatcher staticDispatcher = null; // MONUMENTA
     private final IReloadableResourceManager b;
     public CommandDispatcher commandDispatcher;
     private final CraftingManager d;
@@ -23,7 +24,13 @@ public class DataPackResources implements AutoCloseable {
         this.f = new LootPredicateManager();
         this.g = new LootTableRegistry(this.f);
         this.h = new AdvancementDataWorld(this.f);
-        this.commandDispatcher = new CommandDispatcher(commanddispatcher_servertype);
+        // MONUMENTA START
+        if (staticDispatcher == null) {
+            this.commandDispatcher = new CommandDispatcher(commanddispatcher_servertype);
+        } else {
+            this.commandDispatcher = staticDispatcher;
+        }
+        // MONUMENTA END
         this.i = new CustomFunctionManager(i, this.commandDispatcher.a());
         this.b.a((IReloadListener) this.e);
         this.b.a((IReloadListener) this.f);
diff --git a/src/main/java/org/bukkit/craftbukkit/CraftServer.java b/src/main/java/org/bukkit/craftbukkit/CraftServer.java
index 85023c68a9c85802383cfcf52ec21392abdf3d85..0cc1e0d3166c9143915b8f224a9c1cb375130aa6 100644
--- a/src/main/java/org/bukkit/craftbukkit/CraftServer.java
+++ b/src/main/java/org/bukkit/craftbukkit/CraftServer.java
@@ -455,6 +455,7 @@ public final class CraftServer implements Server {
     public void syncCommands() {
         // Clear existing commands
         CommandDispatcher dispatcher = console.dataPackResources.commandDispatcher = new CommandDispatcher();
+        console.dataPackResources.staticDispatcher = dispatcher;
 
         // Register all commands, vanilla ones will be using the old dispatcher references
         for (Map.Entry<String, Command> entry : commandMap.getKnownCommands().entrySet()) {
